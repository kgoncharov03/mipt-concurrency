Задача А - Алгоритм Петерсона - 2 балла

Ответ: Такой алгоритм Петерсона гарантировать взаимное исключение не будет.
Доказательство: При следующей последовательности действий вызов peterson_mutex.lock() приводит к нарушению взаимного исключения.

victim = 0;

victim = 1;

want[1] = 1

while (want[1 - t].load() && victim.load() == t) { } // Поток 2

want[0] = 1;

while (want[1 - t].load() && victim.load() == t) { } // Поток 1

Циклы в строках 4 и 6 будут пройдены и тогда оба потока попадут в критическую секцию - т.е. взаимное исключение не будет гарантировано.

Задача B - Tricky Mutex - 3 балла

Ответ: Взаимное исключение будет гарантировано, а свобода от взаимной блокировки не будет.
Доказательство:
1) Взаимное исключение
Докажем, что в критической секции всегда будет не более одного потока. Действительно, когда поток входит в критическую секцию, значение thread_count = 0, а далее при каждом прохождении цикла значение thread_count увеличивается на 1 и если поток находится в критической секции, то при вызове unlock() значение thread_count уменьшится на 1.
Пусть для определенности первый поток находится в критической секции. (*) Пусть некоторый другой поток пытается попасть в критическую секцию, проверяя условие в цикле. Поскольку первый поток уже прошёл в секцию, то для текущего потока условие цикла будет ложным и он увеличит thread_count на 1.
Если текущий мьютекс проходит по циклу и уменшает thread_count, то для всех следующих потоков можно сказать то же, что и написано после звёздочки (поскольку они будут находиться в полностью аналогичной ситуации).
Если же текущий поток не идёт по циклу, а следующий пытается захватить цикл, то он просто увеличивает значение thread_count, делая его еще больше.
В обоих случаях в критической секции находится только первый поток и значение thread_count не уменьшилось. Ну а пока thread_count != 0, ни один другой поток не окажется внутри критической секции. (что и требовалось доказать)
2) Взаимная блокировка
Приведём пример такой последовательности, при которой будет нарушаться свобода от взаимной блокировки:
Первый поток успешно захватывает мьютекс и выставляет thread_count = 1

Второй поток безуспешно пытается захватить мьютекс, после чего управление попадает в цикл. При этом thread_count = 2

Первый мьютекс заканчивает выполнение критической секции, освобождает мьютекс и выставляет обратно thread_count = 1

Далее он же (первый) пытается захватить мьютекс, выставляет thread_count = 2

После этого второй поток наконец проходит цикл и делает thread_count = 1

Второй пытается захватить мьютекс, выставляет обратно thread_count = 2

Первый цикл проходит цикл и выставляет thread_count = 1

аналогично 4

аналогично 5

...
Заметим, что команды 4, 5 симметричны командам 6, 7. Из этого факта можно сделать вывод, что, продолжая эту последовательность, будет нарушаться свобода от взаимной блокировки.

Задача 4 - Ticket Spinlock - 3 балла

1) Частота выполнения критических секций в системе значительно упадет, когда число потоков превысит число потоков исполняющихся параллельно. (В большинстве систем это число можно узнать с помошью команды std::thread::hardware_concurrency())
В таком случае может оказаться, что spinlock будет разблокирован, но поток со следующим номером будет находиться в конце очереди, тогда всем потокам придётся тратить своё время в ожидании до того, как планировщик дойдёт до потока, выбранного spinlock'ом.
2) У Test-and-set spinlock такой проблемы не наблюдается, поскольку сразу после разблокировки его займёт поток, который исполняется на данный момент.
